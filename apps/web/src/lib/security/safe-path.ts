/**
 * Safe Path Resolution Utilities
 * Prevents path traversal attacks by ensuring resolved paths stay within allowed directories
 *
 * Uses the shared path validator from @pagespace/lib/security for core validation.
 */

import { resolve, sep, basename, extname } from 'path';
import { realpath } from 'fs/promises';

/**
 * CUID2 identifier pattern - matches user IDs generated by @paralleldrive/cuid2
 * Also matches other alphanumeric identifiers used throughout the codebase.
 * Pattern: 3-64 characters, alphanumeric with hyphens and underscores
 */
const IDENTIFIER_PATTERN = /^[A-Za-z0-9_-]{3,64}$/;

/**
 * Safe filename pattern - alphanumeric, hyphens, underscores, and a single dot for extension
 * No path separators, no double dots, no special characters
 */
const SAFE_FILENAME_PATTERN = /^[a-zA-Z0-9][a-zA-Z0-9_-]*\.[a-zA-Z0-9]+$/;

/**
 * Maximum filename length to prevent DoS via very long strings
 */
const MAX_FILENAME_LENGTH = 255;

/**
 * Allowed image extensions for avatars
 */
const ALLOWED_AVATAR_EXTENSIONS = new Set(['.jpg', '.jpeg', '.png', '.gif', '.webp']);

export interface SafePathResult {
  success: true;
  path: string;
}

export interface SafePathError {
  success: false;
  error: 'invalid_user_id' | 'invalid_filename' | 'path_traversal' | 'invalid_extension';
  message: string;
}

export type SafePathOutcome = SafePathResult | SafePathError;

/**
 * Validates that a user ID is a valid CUID2 identifier
 * Matches the pattern used by @paralleldrive/cuid2 and the processor service
 */
export function isValidUserId(userId: string): boolean {
  return typeof userId === 'string' && IDENTIFIER_PATTERN.test(userId);
}

/**
 * Validates that a filename is safe (no path traversal, valid characters, reasonable length)
 */
export function isValidFilename(filename: string): boolean {
  if (typeof filename !== 'string') return false;
  if (filename.length === 0 || filename.length > MAX_FILENAME_LENGTH) return false;

  // Check for path traversal patterns (including encoded variants - already decoded by Next.js)
  if (filename.includes('..') || filename.includes('/') || filename.includes('\\')) {
    return false;
  }

  // Ensure filename matches safe pattern
  return SAFE_FILENAME_PATTERN.test(filename);
}

/**
 * Validates that a file extension is allowed for avatars
 */
export function isValidAvatarExtension(filename: string): boolean {
  const ext = extname(filename).toLowerCase();
  return ALLOWED_AVATAR_EXTENSIONS.has(ext);
}

/**
 * Safely resolves an avatar path, preventing path traversal attacks
 *
 * NOTE: This performs synchronous validation only. For full security including
 * symlink escape detection, use verifyPathWithinBase() after this function.
 *
 * @param storageBasePath - The base storage directory
 * @param userId - The user ID (must be valid CUID2 identifier)
 * @param filename - The avatar filename
 * @returns SafePathOutcome with either the safe path or an error
 */
export function resolveAvatarPath(
  storageBasePath: string,
  userId: string,
  filename: string
): SafePathOutcome {
  // Validate userId is a valid identifier (CUID2 format)
  if (!isValidUserId(userId)) {
    return {
      success: false,
      error: 'invalid_user_id',
      message: 'Invalid user ID format',
    };
  }

  // Validate filename
  if (!isValidFilename(filename)) {
    return {
      success: false,
      error: 'invalid_filename',
      message: 'Invalid filename format',
    };
  }

  // Validate extension
  if (!isValidAvatarExtension(filename)) {
    return {
      success: false,
      error: 'invalid_extension',
      message: 'File extension not allowed',
    };
  }

  // Resolve the base directory (avatars folder)
  const baseDir = resolve(storageBasePath, 'avatars');

  // Resolve the full file path
  // Using basename() as an extra safety measure to strip any directory components
  const safeFilename = basename(filename);
  const filePath = resolve(baseDir, userId, safeFilename);

  // Verify the resolved path is within the base directory
  // Using sep ensures cross-platform safety (Windows vs Unix)
  if (!filePath.startsWith(baseDir + sep)) {
    return {
      success: false,
      error: 'path_traversal',
      message: 'Access denied',
    };
  }

  return {
    success: true,
    path: filePath,
  };
}

/**
 * Verifies that a file path's real location (after resolving symlinks) is within the base directory.
 * This prevents symlink escape attacks where a symlink inside the allowed directory points outside.
 *
 * @param filePath - The file path to verify
 * @param baseDir - The base directory the file must be within
 * @returns true if the real path is within baseDir, false otherwise
 */
export async function verifyPathWithinBase(filePath: string, baseDir: string): Promise<boolean> {
  try {
    const realFilePath = await realpath(filePath);
    const realBaseDir = await realpath(baseDir);

    // The real path must start with the real base directory + separator
    // This prevents partial matches like /data/avatars-backup matching /data/avatars
    return realFilePath.startsWith(realBaseDir + sep) || realFilePath === realBaseDir;
  } catch {
    // If realpath fails (file doesn't exist, permission denied, etc.), reject
    return false;
  }
}
